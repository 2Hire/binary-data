const createFunction = require('generate-function')
const LinkedList = require('internal/linked-list');

class BufferList {
  /**
   * @constructor
   */
  constructor() {
    this.queue = new LinkedList;
    this.offset = 0;
  }

  /**
   * The number of bytes in list.
   * @returns {number}
   */
  get length() {
    return this.queue.length - this.offset;
  }

  /**
   * Adds an additional buffer or BufferList to the internal list.
   * @param {Buffer|Buffer[]} buf
   */
  append(buf) {
    if (Buffer.isBuffer(buf)) {
      if (this.offset > 0) {
        const head = this.queue.shift()
        this.queue.unshift(head.slice(this.offset))

        this.offset = 0;
      }

      this.queue.push(buf);
    } else if (Array.isArray(buf)) {
      for (let i = 0; i < buf.length; ++i) {
        this.append(buf[i]);
      }
    }
  }

  /**
   * Return the byte at the specified index.
   * @param {number} i
   * @returns {number}
   */
  get(i) {
    while (i >= this.length) {
      i -= this.length;
    }

    while (i < 0) {
      i += this.length;
    }

    let leaf = this.queue.head;
    let offset = this.offset;

    while(leaf) {
      if (leaf.buffer.length - offset > i) {
        return leaf.buffer[i + offset];
      }

      i -= leaf.buffer.length - offset;
      offset = 0;
      leaf = leaf.next;
    }
  }

  /**
   * Returns a new Buffer object containing the bytes within the range specified.
   * @param {number} start
   * @param {number} end
   * @returns {Buffer}
   */
  slice(start, end) {
    if (typeof start !== 'number') {
      start = 0;
    }

    if (typeof end !== 'number') {
      end = this.length;
    }

    while (start < 0) {
      start += this.length;
    }

    while (end < 0) {
      end += this.length;
    }

    end = Math.min(end, this.length);

    if (start >= this.length || end === 0) {
      return Buffer.alloc(0);
    }

    const tmpStart = start;
    start = Math.min(tmpStart, end);
    end = Math.max(tmpStart, end);

    const subset = this.queue.slice(start + this.offset, end + this.offset);

    // Buffer.concat() doesn't have optimization for count == 1
    if (subset.count === 1) {
      return subset.first
    }

    const bufs = new Array(subset.count);
    let leaf = subset.head;

    for(let i = 0; i < bufs.length; ++i) {
      bufs[i] = leaf.buffer;
      leaf = leaf.next;
    }

    return Buffer.concat(bufs, subset.length)
  }

  /**
   * Return a string representation of the buffer.
   * @param {string} encoding
   * @param {number} start
   * @param {number} end
   * @returns {string}
   */
  toString(encoding, start, end) {
    return this.slice(start, end).toString(encoding)
  }

  /**
   * Shift bytes off the start of the list.
   * @param {number} bytes
   */
  consume(bytes) {
    let remainder = bytes;

    while (this.length > 0) {
      const firstLength = this.queue.first.length - this.offset;

      if (remainder >= firstLength) {
        this.queue.shift();

        remainder -= firstLength;
        this.offset = 0;
      } else {
        this.offset += remainder;
        break;
      }
    }
  }
}

const fixedMethods = {
  readDoubleBE: 8,
  readDoubleLE: 8,
  readFloatBE: 4,
  readFloatLE: 4,
  readInt32BE: 4,
  readInt32LE: 4,
  readUInt32BE: 4,
  readUInt32LE: 4,
  readInt16BE: 2,
  readInt16LE: 2,
  readUInt16BE: 2,
  readUInt16LE: 2,
  readInt8: 1,
  readUInt8: 1,
}

Object.keys(fixedMethods).forEach(method => {
  const gen = createFunction()

  gen(`
    function bufferlist_${method}(offset = 0) {
      const start = offset + this.offset;
      const head = this.queue.first;
      const size = ${ gen.formats.d(fixedMethods[method]) };
      const isFirtsChunkEnough = head.length - start >= size;

      return isFirtsChunkEnough
        ? head.${method}(start)
        : this.slice(offset, offset + size).${method}(0)
    }
  `)

  BufferList.prototype[method] = gen.toFunction()
})

const metaMethods = ['readIntBE', 'readIntLE', 'readUIntBE', 'readUIntLE']

metaMethods.forEach(method => {
  const gen = createFunction()

  gen(`
    function bufferlist_${method}(size, offset = 0) {
      const start = offset + this.offset;
      const head = this.queue.first;
      const isFirtsChunkEnough = head.length - start >= size;

      return isFirtsChunkEnough
        ? head.${method}(start, size)
        : this.slice(offset, offset + size).${method}(0, size)
    }
  `)

  BufferList.prototype[method] = gen.toFunction()
})

module.exports = BufferList;
