const LinkedList = require('internal/linked-list');

module.exports = class BufferList {
  /**
   * @constructor
   */
  constructor() {
    this.queue = new LinkedList;
    this.offset = 0;
  }

  /**
   * The number of bytes in list.
   * @returns {number}
   */
  get length() {
    return this.queue.length - this.offset;
  }

  /**
   * Adds an additional buffer or BufferList to the internal list.
   * @param {Buffer|Buffer[]} buf
   */
  append(buf) {
    if (Buffer.isBuffer(buf)) {
      if (this.offset > 0) {
        const head = this.queue.shift()
        this.queue.unshift(head.slice(this.offset))

        this.offset = 0;
      }

      this.queue.push(buf);
    } else if (Array.isArray(buf)) {
      for (let i = 0; i < buf.length; ++i) {
        this.append(buf[i]);
      }
    }
  }

  /**
   * Return the byte at the specified index.
   * @param {number} i
   * @returns {number}
   */
  get(i) {
    while (i >= this.length) {
      i -= this.length;
    }

    while (i < 0) {
      i += this.length;
    }

    let leaf = this.queue.head;
    let offset = this.offset;

    while(leaf) {
      if (leaf.buffer.length - offset > i) {
        return leaf.buffer[i + offset];
      }

      i -= leaf.buffer.length - offset;
      offset = 0;
      leaf = leaf.next;
    }
  }

  /**
   * Returns a new Buffer object containing the bytes within the range specified.
   * @param {number} start
   * @param {number} end
   * @returns {Buffer}
   */
  slice(start, end) {
    if (typeof start !== 'number') {
      start = 0;
    }

    if (typeof end !== 'number') {
      end = this.length;
    }

    while (start < 0) {
      start += this.length;
    }

    while (end < 0) {
      end += this.length;
    }

    end = Math.min(end, this.length);

    if (start >= this.length || end === 0) {
      return Buffer.alloc(0);
    }

    const tmpStart = start;
    start = Math.min(tmpStart, end);
    end = Math.max(tmpStart, end);

    const subset = this.queue.slice(start + this.offset, end + this.offset);

    const bufs = new Array(subset.count);
    let leaf = subset.head;

    for(let i = 0; i < bufs.length; ++i) {
      bufs[i] = leaf.buffer;
      leaf = leaf.next;
    }

    return Buffer.concat(bufs)
  }

  /**
   * Return a string representation of the buffer.
   * @param {string} encoding
   * @param {number} start
   * @param {number} end
   * @returns {string}
   */
  toString(encoding, start, end) {
    return this.slice(start, end).toString(encoding)
  }

  /**
   * Shift bytes off the start of the list.
   * @param {number} bytes
   */
  consume(bytes) {
    let remainder = bytes;

    while (this.length > 0) {
      const firstLength = this.queue.first.length - this.offset;

      if (remainder >= firstLength) {
        this.queue.shift();

        remainder -= firstLength;
        this.offset = 0;
      } else {
        this.offset += remainder;
        break;
      }
    }
  }

  readDoubleBE(offset = 0) {
    return readNumber(this, 'readDoubleBE', 8, offset);
  }

  readDoubleLE(offset = 0) {
    return readNumber(this, 'readDoubleLE', 8, offset);
  }

  readFloatBE(offset = 0) {
    return readNumber(this, 'readFloatBE', 4, offset);
  }

  readFloatLE(offset = 0) {
    return readNumber(this, 'readFloatLE', 4, offset);
  }

  readInt8(offset = 0) {
    return readNumber(this, 'readInt8', 1, offset);
  }

  readUInt8(offset = 0) {
    return readNumber(this, 'readUInt8', 1, offset);
  }

  readInt16BE(offset = 0) {
    return readNumber(this, 'readInt16BE', 2, offset);
  }

  readUInt16BE(offset = 0) {
    return readNumber(this, 'readUInt16BE', 2, offset);
  }

  readInt16LE(offset = 0) {
    return readNumber(this, 'readInt16LE', 2, offset);
  }

  readUInt16LE(offset = 0) {
    return readNumber(this, 'readUInt16LE', 2, offset);
  }

  readInt32BE(offset = 0) {
    return readNumber(this, 'readInt32BE', 4, offset);
  }

  readInt32LE(offset = 0) {
    return readNumber(this, 'readInt32LE', 4, offset);
  }

  readUInt32BE(offset = 0) {
    return readNumber(this, 'readUInt32BE', 4, offset);
  }

  readUInt32LE(offset = 0) {
    return readNumber(this, 'readUInt32LE', 4, offset);
  }

  readIntBE(size, offset = 0) {
    return readBigNumber(this, 'readIntBE', size, offset);
  }

  readIntLE(size, offset = 0) {
    return readBigNumber(this, 'readIntLE', size, offset);
  }

  readUIntBE(size, offset = 0) {
    return readBigNumber(this, 'readUIntBE', size, offset);
  }

  readUIntLE(size, offset = 0) {
    return readBigNumber(this, 'readUIntLE', size, offset);
  }
}

/**
 * Read number from buffer.
 * @param {BufferList} bl
 * @param {string} method
 * @param {number} size
 * @param {number} offset
 * @returns {number}
 */
function readNumber(bl, method, size, offset) {
  const start = offset + bl.offset
  const head = bl.queue.first
  const isFirtsChunkEnough = head.length - start >= size

  return isFirtsChunkEnough ? head[method](start) : bl.slice(offset, offset + size)[method](0)
}

/**
 * Read number from buffer.
 * @param {BufferList} bl
 * @param {string} method
 * @param {number} size
 * @param {number} offset
 * @returns {number}
 */
function readBigNumber(bl, method, size, offset) {
  const start = offset + bl.offset
  const head = bl.queue.first
  const isFirtsChunkEnough = head.length - start >= size

  return isFirtsChunkEnough ? head[method](start, size) : bl.slice(offset, offset + size)[method](0, size)
}
