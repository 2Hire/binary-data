const { isType } = require('lib/util')

module.exports = string

function string(length, encoding = 'ascii') {
  if (!Buffer.isEncoding(encoding)) {
    throw new Error('Argument #2 should be an encoding name.')
  }

  if (typeof length === 'number') {
    return {
      encode: encodeFixedString(length, encoding),
      decode: decodeFixedString(length, encoding),
      encodingLength: () => length,
    }
  }

  if (isType(length)) {
    return {
      encode: encodeSizePrefixedString(length, encoding),
      decode: decodeSizePrefixedString(length, encoding),
      encodingLength: encodingLengthSizePrefixedString(length, encoding),
    }
  }

  if (length === null) {
    return {
      encode: encodeNullString(encoding),
      decode: decodeNullString(encoding),
      encodingLength(value) {
        return Buffer.byteLength(value, encoding) + 1
      },
    }
  }

  if (typeof length === 'function') {
    return {
      encode: encodeCallback(length, encoding),
      decode: decodeCallback(length, encoding),
      encodingLength(value) {
        return Buffer.byteLength(value, encoding)
      },
    }
  }

  throw new TypeError('Unknown type of argument #1.')
}

function encodeNullString(encoding) {
  return function encode(value, wstream) {
    const buf = Buffer.from(value.toString(), encoding)

    wstream.writeBuffer(buf)
    wstream.writeInt8(0)

    encode.bytes = buf.length + 1
  }
}

function decodeNullString(encoding) {
  // eslint-disable-next-line func-names
  return function decode(rstream) {
    let bytes = 0

    while (rstream.get(bytes) !== 0) {
      ++bytes

      if (bytes >= rstream.length) {
        throw new RangeError('Out of bounds.')
      }
    }

    const bytesWithNull = bytes + 1
    const buf = rstream.readBuffer(bytesWithNull)
    decode.bytes = bytesWithNull

    return buf.toString(encoding, 0, bytes)
  }
}

function encodeFixedString(size, encoding) {
  return function encode(value, wstream) {
    value = value.toString()

    if (Buffer.byteLength(value, encoding) !== size) {
      throw new Error(`Size of string should be ${size} in bytes.`)
    }

    const buf = Buffer.from(value, encoding)

    wstream.writeBuffer(buf)
    encode.bytes = buf.length
  }
}

function decodeFixedString(size, encoding) {
  // eslint-disable-next-line func-names
  return function decode(rstream) {
    const buf = rstream.readBuffer(size)
    decode.bytes = size

    return buf.toString(encoding)
  }
}

function encodeSizePrefixedString(type, encoding) {
  return function encode(value, wstream) {
    value = value.toString()

    // eslint-disable-next-line no-invalid-this
    const context = this

    type.encode.call(context, Buffer.byteLength(value, encoding), wstream)
    encode.bytes = type.encode.bytes

    const buf = Buffer.from(value, encoding)

    wstream.writeBuffer(buf)
    encode.bytes += buf.length
  }
}

function decodeSizePrefixedString(type, encoding) {
  // eslint-disable-next-line func-names
  return function decode(rstream) {
    // eslint-disable-next-line no-invalid-this
    const size = type.decode.call(this, rstream)

    if (typeof size !== 'number') {
      throw new TypeError('Size of a string should be a number.')
    }

    const buf = rstream.readBuffer(size)
    decode.bytes = type.decode.bytes + buf.length

    return buf.toString(encoding)
  }
}

function encodingLengthSizePrefixedString(type, encoding) {
  // eslint-disable-next-line func-names
  return function encodingLength(value) {
    const size = Buffer.byteLength(value, encoding)

    return type.encodingLength(size) + size
  }
}

function encodeCallback(callback, encoding) {
  // eslint-disable-next-line func-names
  return function encode(value, wstream) {
    encode.bytes = 0

    // eslint-disable-next-line no-invalid-this
    const context = this

    const expectedLength = callback(context)
    const buf = Buffer.from(value.toString(), encoding)

    checkLengthType(expectedLength)
    checkLength(expectedLength, buf.length)

    wstream.writeBuffer(buf)
    encode.bytes += buf.length
  }
}

function decodeCallback(callback, encoding) {
  // eslint-disable-next-line func-names
  return function decode(rstream) {
    // eslint-disable-next-line no-invalid-this
    const size = callback(this)
    checkLengthType(size)

    const buf = rstream.readBuffer(size)
    decode.bytes = size

    return buf.toString(encoding)
  }
}

function checkLengthType(length) {
  if (typeof length !== 'number') {
    throw new TypeError('Length of a buffer should be a number.')
  }
}

function checkLength(requiredSize, havingSize) {
  if (requiredSize !== havingSize) {
    throw new Error(
      `Buffer required length ${requiredSize} instead of ${havingSize}`
    )
  }
}
