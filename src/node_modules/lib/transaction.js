'use strict';

const NotEnoughDataError = require('lib/not-enough-data-error');

const temporary = Buffer.alloc(8);

/**
 * Helps to read the whole data chunk.
 */
class Transaction {
  /**
   * @class Transaction
   * @param {DecodeStream} stream
   */
  constructor(stream) {
    this.stream = stream;
    this.index = 0;
  }

  /**
   * Confirm reading and removes data from stream.
   */
  commit() {
    this.stream.consume(this.index);
  }

  /**
   * Get byte from stream by index.
   * @param {number} i
   * @returns {number}
   */
  get(i = 0) {
    return this.stream.get(this.index + i);
  }

  /**
   * Get the number of bytes in stream.
   * @returns {number}
   */
  get length() {
    return this.stream.length;
  }

  /**
   * Read provided amount of bytes from stream.
   * @param {number} size
   * @returns {Buffer}
   */
  readBuffer(size) {
    assertSize(this.index + size, this.length);

    const buf = this.stream.slice(this.index, this.index + size);
    this.index += size;

    return buf;
  }
}

const methods = {
  readDoubleBE: 8,
  readDoubleLE: 8,
  readFloatBE: 4,
  readFloatLE: 4,
  readInt32BE: 4,
  readInt32LE: 4,
  readUInt32BE: 4,
  readUInt32LE: 4,
  readInt16BE: 2,
  readInt16LE: 2,
  readUInt16BE: 2,
  readUInt16LE: 2,
  readInt8: 1,
  readUInt8: 1,
};

Object.keys(methods).forEach(method => {
  const bytes = methods[method];

  Transaction.prototype[method] = function read() {
    fastread(this.stream, bytes, this.index);
    this.index += bytes;
    return temporary[method](0);
  };
});
['readIntBE', 'readIntLE', 'readUIntBE', 'readUIntLE'].forEach(method => {
  Transaction.prototype[method] = function read(bytes) {
    fastread(this.stream, bytes, this.index);
    this.index += bytes;
    return temporary[method](0, bytes);
  };
});

module.exports = Transaction;

/**
 * Check if stream is able to read requested amound of data.
 * @param {number} size Requested data size to read.
 * @param {number} length The number of bytes in stream.
 */
function assertSize(size, length) {
  if (size > length) {
    throw new NotEnoughDataError(size, length);
  }
}

/**
 * @param {DecodeStream} stream
 * @param {number} size
 * @param {number} i
 */
function fastread(stream, size, i) {
  assertSize(size + i, stream.length);
  stream.copy(temporary, 0, i, i + size);
}
