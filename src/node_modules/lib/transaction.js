const NotEnoughDataError = require('lib/not-enough-data-error')

const temporary = Buffer.alloc(8)

// Called in object stream.
class Transaction {
  constructor(stream) {
    this.stream = stream
    this.index = 0
  }

  commit() {
    this.stream.consume(this.index)
  }

  get(i) {
    return this.stream.get(i)
  }

  get length() {
    return this.stream.length
  }

  readBuffer(size) {
    assertSize(this.index + size, this.length)

    const buf = this.stream.slice(this.index, this.index + size)
    this.index += size

    return buf
  }
}

const methods = {
  readDoubleBE: 8,
  readDoubleLE: 8,
  readFloatBE: 4,
  readFloatLE: 4,
  readInt32BE: 4,
  readInt32LE: 4,
  readUInt32BE: 4,
  readUInt32LE: 4,
  readInt16BE: 2,
  readInt16LE: 2,
  readUInt16BE: 2,
  readUInt16LE: 2,
  readInt8: 1,
  readUInt8: 1,
}

Object.keys(methods).forEach(method => {
  const bytes = methods[method]

  Transaction.prototype[method] = function() {
    fastread(this.stream, bytes, this.index)
    this.index += bytes
    return temporary[method](0)
  }
})
;['readIntBE', 'readIntLE', 'readUIntBE', 'readUIntLE'].forEach(method => {
  Transaction.prototype[method] = function(bytes) {
    fastread(this.stream, bytes, this.index)
    this.index += bytes
    return temporary[method](0, bytes)
  }
})

module.exports = Transaction

function assertSize(size, length) {
  if (size > length) {
    throw new NotEnoughDataError(size, length)
  }
}

function fastread(stream, size, i) {
  assertSize(size + i, stream.length)
  stream.copy(temporary, 0, i, i + size)
}
