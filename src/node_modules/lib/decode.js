const { isType, isUserType, isDecodeType } = require('lib/util')
const DecodeStream = require('streams/decode')
const symbols = require('internal/symbols')
const Metadata = require('internal/meta')

module.exports = {
  decode,
  decodeCommon,
}

function decode(rstream, typeOrSchema) {
  if (Buffer.isBuffer(rstream)) {
    rstream = new DecodeStream(rstream)
  }

  const meta = new Metadata()
  const value = decodeCommon(rstream, typeOrSchema, meta)

  decode.bytes = meta.bytes
  meta.context = undefined

  return value
}

/**
 * @param {DecodeStream|Buffer} rstream
 * @param {object} typeOrSchema
 * @param {Metadata} meta
 * @returns {*}
 */
function decodeCommon(rstream, typeOrSchema, meta) {
  if (isType(typeOrSchema)) {
    return typeOrSchema.decode(rstream, meta)
  }

  return decodeSchema(rstream, typeOrSchema, meta)
}

/**
 * @param {DecodeStream} rstream
 * @param {object} schema
 * @param {Metadata} meta
 * @returns {object}
 */
function decodeSchema(rstream, schema, meta) {
  assertSchema(schema)

  const result = Object.create(null)

  if (meta.context === undefined) {
    meta.context = {
      node: result,
      currentNode: result,
    }
  } else {
    meta.context.currentNode = result
  }

  const keys = Object.keys(schema)

  for (let i = 0; i < keys.length; ++i) {
    const key = keys[i]
    const type = schema[key]

    if (!isDecodeType(type)) {
      result[key] = decodeSchema(rstream, type, meta)
      meta.context.currentNode = result
      continue
    }

    const value = type.decode(rstream, meta)

    if (type[symbols.skip] === true) {
      continue
    }

    result[key] = value
  }

  return result
}

function assertSchema(schema) {
  if (!isUserType(schema)) {
    throw new TypeError('Argument #2 should be a plain object.')
  }
}
