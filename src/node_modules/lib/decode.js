const { isType, isUserType, isDecodeType } = require('lib/util')
const DecodeStream = require('streams/decode')
const symbols = require('internal/symbols')
const Metadata = require('internal/meta')

module.exports = {
  decode,
  decodeCommon,
}

function decode(rstream, typeOrSchema) {
  if (Buffer.isBuffer(rstream)) {
    rstream = new DecodeStream(rstream)
  }

  const meta = new Metadata()
  const value = decodeCommon(rstream, typeOrSchema, meta)

  decode.bytes = meta.bytes
  Metadata.clean(meta)

  return value
}

/**
 * @param {DecodeStream|Buffer} rstream
 * @param {object} typeOrSchema
 * @param {Metadata} meta
 * @returns {*}
 */
function decodeCommon(rstream, typeOrSchema, meta) {
  if (isType(typeOrSchema)) {
    const value = typeOrSchema.decode.call(meta, rstream)
    meta[symbols.bytes] += typeOrSchema.decode.bytes
    return value
  }

  return decodeSchema(rstream, typeOrSchema, meta)
}

/**
 * @param {DecodeStream} rstream
 * @param {object} schema
 * @param {Metadata} meta
 * @returns {object}
 */
function decodeSchema(rstream, schema, meta) {
  assertSchema(schema)

  const node = Object.create(null)

  if (meta.node === undefined) {
    meta.node = node
    meta.current = node
  } else {
    meta.current = node
  }

  const keys = Object.keys(schema)

  for (let i = 0; i < keys.length; ++i) {
    const key = keys[i]
    const type = schema[key]

    if (!isDecodeType(type)) {
      node[key] = decodeSchema(rstream, type, meta)
      meta.current = node
      continue
    }

    const value = type.decode.call(meta, rstream)
    meta[symbols.bytes] += type.decode.bytes

    if (type[symbols.skip] === true) {
      continue
    }

    node[key] = value
  }

  return node
}

function assertSchema(schema) {
  if (!isUserType(schema)) {
    throw new TypeError('Argument #2 should be a plain object.')
  }
}
