const { isUserType, isEncodeType, isType } = require('lib/util')
const symbols = require('internal/symbols')
const Metadata = require('internal/meta')

module.exports = {
  encode,
  encodeCommon,
}

/**
 * @param {any} object
 * @param {EncodeStream} wstream
 * @param {any} typeOrSchema
 */
function encode(object, wstream, typeOrSchema) {
  const meta = new Metadata()

  encodeCommon(object, wstream, typeOrSchema, meta)

  encode.bytes = meta.bytes
  Metadata.clean(meta)
}

/**
 * @param {any} object
 * @param {EncodeStream} wstream
 * @param {any} typeOrSchema
 * @param {Metadata} context
 */
function encodeCommon(object, wstream, typeOrSchema, context) {
  if (isType(typeOrSchema)) {
    typeOrSchema.encode.call(context, object, wstream)
    context[symbols.bytes] += typeOrSchema.encode.bytes
  } else {
    encodeSchema(object, wstream, typeOrSchema, context)
  }
}

/**
 * @param {any} object
 * @param {EncodeStream} wstream
 * @param {any} schema
 * @param {Metadata} context
 */
function encodeSchema(object, wstream, schema, context) {
  assertSchema(schema)

  if (context.node === undefined) {
    context.node = object
    context.current = object
  } else {
    context.current = object
  }

  const keys = Object.keys(schema)

  for (let i = 0; i < keys.length; ++i) {
    const key = keys[i]
    const type = schema[key]
    const value = object[key]

    if (!isEncodeType(type)) {
      encodeSchema(value, wstream, type, context)
      context.current = object

      continue
    }

    type.encode.call(context, value, wstream)
    context[symbols.bytes] += type.encode.bytes
  }
}

function assertSchema(schema) {
  if (!isUserType(schema)) {
    throw new TypeError('Argument `schema` should be a plain object.')
  }
}
