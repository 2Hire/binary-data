const createFunction = require('generate-function')
const AbstractStream = require('streams/abstract-stream')
const NotEnoughDataError = require('lib/not-enough-data-error')

class DecodeStream extends AbstractStream {
  constructor(options = {}) {
    let buf = null

    if (Buffer.isBuffer(options)) {
      buf = options
      options = {}
    }

    options.readableObjectMode = true
    options.writableObjectMode = false
    super(options)

    if (buf !== null) {
      this.append(buf)
    }
  }

  readBuffer(size) {
    assertSize(size, this.length)

    const buf = this.slice(0, size)
    this.consume(size)

    return buf
  }
}

const fixedMethods = {
  readDoubleBE: 8,
  readDoubleLE: 8,
  readFloatBE: 4,
  readFloatLE: 4,
  readInt32BE: 4,
  readInt32LE: 4,
  readUInt32BE: 4,
  readUInt32LE: 4,
  readInt16BE: 2,
  readInt16LE: 2,
  readUInt16BE: 2,
  readUInt16LE: 2,
  readInt8: 1,
  readUInt8: 1,
}

const metaMethods = ['readIntBE', 'readIntLE', 'readUIntBE', 'readUIntLE']

Object.keys(fixedMethods).forEach(method => {
  const gen = createFunction()

  gen(`
    function ${method}() {
      const bytes = ${ gen.formats.d(fixedMethods[method]) };
      assertSize(bytes, this.length);

      const res = this.buffer.${method}(0);
      this.consume(bytes);

      return res;
    }
  `)

  DecodeStream.prototype[method] = gen.toFunction({ assertSize })
})

metaMethods.forEach(method => {
  const gen = createFunction()

  gen(`
    function ${method}(size) {
      assertSize(size, this.length);

      const res = this.buffer.${method}(size, 0);
      this.consume(size);
      return res;
    }
  `)

  DecodeStream.prototype[method] = gen.toFunction({ assertSize })
})

module.exports = DecodeStream

function assertSize(size, length) {
  if (size > length) {
    throw new NotEnoughDataError(size, length)
  }
}

